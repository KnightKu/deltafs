/*
 * Copyright (c) 2015-2017 Carnegie Mellon University.
 *
 * All rights reserved.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. See the AUTHORS file for names of contributors.
 */

#include "deltafs_plfsio_filter.h"
#include "deltafs_plfsio_format.h"

#include "deltafs_plfsio.h"

#include <assert.h>
#include <algorithm>
#include <typeinfo>  // operator typeid

namespace pdlfs {
namespace plfsio {

// Return the position of the left most "1" bit, such that
//   LeftMostBit(0x00) = 0
//   LeftMostBit(0x01) = 1
//   LeftMostBit(0x02) = 2
//   LeftMostBit(0x04) = 3
//   ...
static unsigned char LeftMostBit(uint32_t i) {
  if (i == 0) return 0;  // Special case
  unsigned char result;
#if defined(__GNUC__)
  result = static_cast<unsigned char>(32 - __builtin_clz(i));
#else
  unsigned int n = 1;
  if (i >> 16 == 0) {
    n += 16;
    i <<= 16;
  }
  if (i >> 24 == 0) {
    n += 8;
    i <<= 8;
  }
  if (i >> 28 == 0) {
    n += 4;
    i <<= 4;
  }
  if (i >> 30 == 0) {
    n += 2;
    i <<= 2;
  }
  n -= i >> 31;
  result = static_cast<unsigned char>(32 - n);
#endif
  return result;
}

BloomBlock::BloomBlock(const DirOptions& options, size_t bytes_to_reserve)
    : bits_per_key_(options.bf_bits_per_key) {
  // Round down to reduce probing cost a little bit
  k_ = static_cast<uint32_t>(bits_per_key_ * 0.69);  // 0.69 =~ ln(2)
  if (k_ < 1) k_ = 1;
  if (k_ > 30) k_ = 30;
  // Reserve an extra byte for storing the k
  if (bytes_to_reserve != 0) {
    space_.reserve(bytes_to_reserve + 1);
  }
  finished_ = true;  // Pending further initialization
  bits_ = 0;
}

BloomBlock::~BloomBlock() {}

int BloomBlock::chunk_type() {
  return static_cast<int>(kSbfChunk);  // Standard bloom filter
}

void BloomBlock::Reset(uint32_t num_keys) {
  bits_ = static_cast<uint32_t>(num_keys * bits_per_key_);
  // For small n, we can see a very high false positive rate.
  // Fix it by enforcing a minimum bloom filter length.
  if (bits_ < 64) {
    bits_ = 64;
  }
  uint32_t bytes = (bits_ + 7) / 8;
  finished_ = false;
  space_.clear();
  space_.resize(bytes, 0);
  // Remember # of probes in filter
  space_.push_back(static_cast<char>(k_));
  // Finalize # bits
  bits_ = bytes * 8;
}

void BloomBlock::AddKey(const Slice& key) {
  assert(!finished_);  // Finish() has not been called
  // Use double-hashing to generate a sequence of hash values.
  uint32_t h = BloomHash(key);
  const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
  for (size_t j = 0; j < k_; j++) {
    const uint32_t b = h % bits_;
    space_[b / 8] |= (1 << (b % 8));
    h += delta;
  }
}

Slice BloomBlock::Finish() {
  assert(!finished_);
  finished_ = true;
  return space_;
}

bool BloomKeyMayMatch(const Slice& key, const Slice& input) {
  const size_t len = input.size();
  if (len < 2) {
    return true;  // Consider it a match
  }
  const uint32_t bits = static_cast<uint32_t>((len - 1) * 8);

  const char* array = input.data();
  // Use the encoded k so that we can read filters generated by
  // bloom filters created using different parameters.
  const uint32_t k = static_cast<unsigned char>(array[len - 1]);
  if (k > 30) {
    // Reserved for potentially new encodings for short bloom filters.
    // Consider it a match.
    return true;
  }

  uint32_t h = BloomHash(key);
  const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
  for (size_t j = 0; j < k; j++) {
    const uint32_t b = h % bits;
    if ((array[b / 8] & (1 << (b % 8))) == 0) {
      return false;
    }
    h += delta;
  }

  return true;
}

// Encoding a bitmap as-is, uncompressed. Used for debugging only.
// Not intended for production.
class UncompressedFormat {
 public:
  UncompressedFormat(const DirOptions& options, std::string* space)
      : key_bits_(options.bm_key_bits), space_(space) {
    bits_ = 1u << key_bits_;  // Logic domain space (total # unique keys)
  }

  void Reset(uint32_t num_keys) {
    space_->clear();
    const size_t bytes = (bits_ + 7) / 8;  // Bitmap size (uncompressed)
    space_->resize(bytes, 0);
  }

  // Set the i-th bit to "1". If the i-th bit is already set,
  // no action needs to be taken.
  void Set(uint32_t i) {
    assert(i < bits_);  // Must not flow out of the key space
    (*space_)[i / 8] |= 1 << (i % 8);
  }

  // Finalize the bitmap representation.
  // Return the final buffer size.
  size_t Finish() { return space_->size(); }

  // Return true iff the i-th bit is set in the given bitmap.
  static bool Test(uint32_t i, size_t key_bits, const Slice& input) {
    const size_t bits = input.size() * 8;
    if (i < bits) {
      return 0 != (input[i / 8] & (1 << (i % 8)));
    } else {
      return false;
    }
  }

  // Report total memory consumption.
  size_t memory_usage() const {
    size_t result = space_->capacity();
    return result;
  }

 private:
  // Key size in bits
  const size_t key_bits_;
  // Underlying space for the bitmap
  std::string* const space_;
  // Total bits in the bitmap
  size_t bits_;
};

// Encoding a bitmap in-memory using a roaring-like bucketized bitmap
// representation for fast accesses. Final storage representation
// is not implemented, and is the job of the subclasses.
class CompressedFormat {
 public:
  CompressedFormat(const DirOptions& options, std::string* space)
      : bytes_per_bucket_(0),
        estimated_bucket_size_(0),
        num_keys_(0),
        key_bits_(options.bm_key_bits),
        space_(space) {
    bits_ = 1u << key_bits_;  // Logic domain space (total num of unique keys)
    num_buckets_ = 1u << (key_bits_ - 8);  // Each bucket manages 256 keys
  }

  // Reset filter state and resize the underlying buffer space.
  // Use num_keys to estimate bitmap density.
  void Reset(uint32_t num_keys) {
    num_keys_ = num_keys;
    extra_keys_.clear();
    working_space_.clear();
    // Estimated number of user keys per bucket. The actual number
    // for each bucket may differ. Works best when user keys
    // are uniformly distributed.
    // Each key only takes 1 byte to store.
    estimated_bucket_size_ = (num_keys + num_buckets_ - 1) / num_buckets_;
    // Use an extra byte to store the actual number
    // of user keys inserted at each bucket.
    bytes_per_bucket_ = estimated_bucket_size_ + 1;
    working_space_.resize(bytes_per_bucket_ * num_buckets_, 0);
    space_->clear();
  }

  // Set the i-th bit to "1". If the i-th bit is already set,
  // no action needs to be taken.
  void Set(uint32_t i) {
    const uint32_t bucket_index = i >> 8;
    // Obtain current bucket size
    assert(bytes_per_bucket_ == estimated_bucket_size_ + 1);
    size_t bucket_size = static_cast<unsigned char>(
        working_space_[bucket_index * bytes_per_bucket_]);
    // Update bucket size
    working_space_[bucket_index * bytes_per_bucket_] =
        static_cast<char>(bucket_size + 1);
    if (bucket_size < estimated_bucket_size_) {
      working_space_[bucket_index * bytes_per_bucket_ + 1 + bucket_size] =
          static_cast<char>(i & 0xFF);
    } else {
      extra_keys_.push_back(i);
    }
  }

  // Report total memory consumption.
  size_t memory_usage() const {
    size_t result = 0;
    result += working_space_.capacity();
    result += extra_keys_.capacity() * sizeof(uint32_t);
    result += space_->capacity();
    return result;
  }

 protected:
  class Iter {  // Iterate through all bitmap buckets in working_space_
   public:
    // REQUIRES: parent.extra_keys is sorted
    explicit Iter(const CompressedFormat& parent)
        : bytes_per_bucket_(parent.bytes_per_bucket_),
          estimated_bucket_size_(parent.estimated_bucket_size_),
          num_buckets_(parent.num_buckets_),
          working_space_(parent.working_space_.data()) {
      bucket_keys_.reserve(16);
      iter_end_ = parent.extra_keys_.end();
      iter_ = parent.extra_keys_.begin();
      bucket_index_ = 0;  // Seek to the first bucket
      if (Valid()) {
        Fetch();
      }
    }

    // Return a pointer to the bucket keys
    // Contents valid until the next Next() call.
    std::vector<uint32_t>* keys() { return &bucket_keys_; }

    bool Valid() const {  // True iff bucket exists
      return bucket_index_ < num_buckets_;
    }

    void Next() {
      bucket_index_++;
      if (Valid()) {
        Fetch();
      }
    }

   private:
    // Retrieve all keys belonging to the current bucket.
    // Results are not sorted.
    void Fetch() {
      bucket_keys_.clear();
      const uint32_t bucket_size = static_cast<unsigned char>(
          working_space_[bytes_per_bucket_ * bucket_index_]);
      for (uint32_t i = 0; i < bucket_size; i++) {
        if (i < estimated_bucket_size_) {
          uint32_t key_offset = static_cast<unsigned char>(
              working_space_[bytes_per_bucket_ * bucket_index_ + 1 + i]);
          bucket_keys_.push_back(key_offset + (bucket_index_ << 8));
        } else {
          assert(iter_ != iter_end_);
          bucket_keys_.push_back(*iter_);
          ++iter_;
        }
      }
    }

    // Constant after construction
    const size_t bytes_per_bucket_;
    const size_t estimated_bucket_size_;
    const size_t num_buckets_;

    const char* working_space_;

    // Temp storage for all keys in the current bucket
    std::vector<uint32_t> bucket_keys_;
    // Cursor to the extra keys
    std::vector<uint32_t>::const_iterator iter_end_;
    std::vector<uint32_t>::const_iterator iter_;
    // Current bucket index
    uint32_t bucket_index_;
  };

  // Finalize the bitmap representation.
  // Return the final buffer size.
  // Not a virtual function.
  size_t Finish() {
    std::sort(extra_keys_.begin(), extra_keys_.end());
    // To be overridden by subclasses...
    return 0;
  }

  // Number of user keys for each lookup entry
  static const size_t partition_size_ = 1024;

  // In-memory bitmap storage where the entire bitmap
  // is divided into a set of fixed-sized bucket.
  // Each bucket is responsible for 256 keys. User keys inserted
  // are assumed to be uniformly distributed over the key space
  // so each bucket will get approximately bucket_size_ =
  // num_keys / num_buckets_ keys.
  // |<-               key space               ->|  // 2**key_bits_ keys
  //    bucket-0,   bucket-1,   bucket-2, ...  // num_buckets_
  std::string working_space_;  // Temp bitmap storage
  // For keys that cannot fit into the statically allocated buckets
  std::vector<uint32_t> extra_keys_;
  size_t bytes_per_bucket_;  // Use an extra byte for bucket size
  // Estimated number of keys per bucket
  size_t estimated_bucket_size_;
  // Total number of buckets
  size_t num_buckets_;

  // Number of user keys in the bitmap
  size_t num_keys_;

  // Key size in bits
  const size_t key_bits_;  // Domain space
  // Space for the final representation
  std::string* const space_;
  // Logic bits in the bitmap. The actual memory or storage
  // used may differ due to compression and formatting.
  size_t bits_;
};

// VbFormat: encode each bitmap using a varint-based scheme.
// Varint is also named VByte, or VB.
class VbFormat : public CompressedFormat {
 public:
  VbFormat(const DirOptions& options, std::string* space)
      : CompressedFormat(options, space) {}

  static void VbEnc(std::string* output, uint32_t value) {
    // While more than 7 bits of data are left, emit the least 7 bits
    // and set the next-byte flag
    while (value > 127) {
      // |128: Set the next byte flag
      output->push_back((value & 127) | 128);
      // Remove the 7 bits we just wrote
      value >>= 7;
    }
    output->push_back(value & 127);
  }

  // Convert the in-memory bitmap representation to an on-storage
  // representation. The in-memory version is stored at working_space_.
  // The on-storage version will be stored in *space_.
  size_t Finish() {
    uint32_t last_key = 0;
    CompressedFormat::Finish();  // Sort extra keys
    Iter bucket_iter(*this);
    for (; bucket_iter.Valid(); bucket_iter.Next()) {
      std::vector<uint32_t>* bucket_keys = bucket_iter.keys();
      std::sort(bucket_keys->begin(), bucket_keys->end());
      for (std::vector<uint32_t>::iterator it = bucket_keys->begin();
           it != bucket_keys->end(); ++it) {
        uint32_t dta = *it - last_key;
        VbEnc(space_, dta);
        last_key = *it;
      }
    }

    return space_->size();
  }

  static uint32_t VbDec(Slice* input) {
    uint32_t result = 0;
    for (size_t i = 0; !input->empty(); i++) {
      unsigned char b = static_cast<unsigned char>((*input)[0]);
      input->remove_prefix(1);
      result |= (b & 127) << (7 * i);
      // If the next-byte flag is set
      if (!(b & 128)) {
        break;
      }
    }
    return result;
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& bitmap) {
    uint32_t base = 0;
    Slice input = bitmap;
    while (!input.empty()) {
      base += VbDec(&input);
      if (base == bit) {
        return true;
      } else if (base > bit) {
        return false;
      }
    }
    return false;
  }
};

// Very similar to VbFormat except that the first byte is
// encoded as a special full byte.
class VbPlusFormat : public VbFormat {
 public:
  VbPlusFormat(const DirOptions& options, std::string* space)
      : VbFormat(options, space) {}

  static void VbPlusEnc(std::string* output, uint32_t value) {
    if (value < 255) {
      output->push_back(value);  // Encode the byte as-is
    } else {
      output->push_back(255);
      value -= 254;  // Continue with varint
      VbEnc(output, value);
    }
  }

  // Convert the in-memory bitmap representation to an on-storage
  // representation. The in-memory version is stored at working_space_.
  // The on-storage version will be stored in *space_.
  size_t Finish() {
    uint32_t last_key = 0;
    CompressedFormat::Finish();  // Sort extra keys
    Iter bucket_iter(*this);
    for (; bucket_iter.Valid(); bucket_iter.Next()) {
      std::vector<uint32_t>* bucket_keys = bucket_iter.keys();
      std::sort(bucket_keys->begin(), bucket_keys->end());
      for (std::vector<uint32_t>::iterator it = bucket_keys->begin();
           it != bucket_keys->end(); ++it) {
        uint32_t dta = *it - last_key;
        VbPlusEnc(space_, dta);
        last_key = *it;
      }
    }

    return space_->size();
  }

  static uint32_t VbPlusDec(Slice* input) {
    uint32_t result = 0;
    if (!input->empty()) {
      unsigned char b = static_cast<unsigned char>((*input)[0]);
      input->remove_prefix(1);
      if (b == 255) {
        result = VbDec(input) + 254;
      } else {
        result = b;
      }
    }
    return result;
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& bitmap) {
    uint32_t base = 0;
    Slice input = bitmap;
    while (!input.empty()) {
      base += VbPlusDec(&input);
      if (base == bit) {
        return true;
      } else if (base > bit) {
        return false;
      }
    }
    return false;
  }
};

static void EncodingSizeT(std::string* space, size_t index, size_t value) {
  (*space)[index] = static_cast<unsigned char>(value & 0xff);
  (*space)[index + 1] = static_cast<unsigned char>((value >> 8) & 0xff);
  (*space)[index + 2] = static_cast<unsigned char>((value >> 16) & 0xff);
  (*space)[index + 3] = static_cast<unsigned char>((value >> 24) & 0xff);
}

static size_t DecodingSizeT(const Slice& input, size_t index) {
  size_t value = 0;
  value += static_cast<unsigned char>(input[index]);
  value += static_cast<unsigned char>(input[index + 1]) << 8;
  value += static_cast<unsigned char>(input[index + 2]) << 16;
  value += static_cast<unsigned char>(input[index + 3]) << 24;
  return value;
}

// Similar to VbPlusFormat but with an extra lookup table for faster queries.
// A lookup entry is inserted for each partition_size_ keys.
// Each lookup entry costs 8 bytes, using 4 bytes for an offset,
// and another 4 bytes for a delta prefix.
class FastVbPlusFormat : public VbPlusFormat {
 public:
  FastVbPlusFormat(const DirOptions& options, std::string* space)
      : VbPlusFormat(options, space) {}

  // Convert the in-memory bitmap representation to an on-storage
  // representation. The in-memory version is stored at working_space_.
  // The on-storage version will be stored in *space_.
  size_t Finish() {
    uint32_t last_key = 0;
    // Accumulated delta covering deltas both before and in
    // the current partition
    uint32_t partition_dta_prefix = 0;
    size_t partition_index = 0;
    size_t partition_num_keys = 0;
    CompressedFormat::Finish();  // Sort extra keys
    size_t num_partitions = (num_keys_ + partition_size_ - 1) / partition_size_;
    if (num_partitions == 0) num_partitions = 1;
    space_->resize(num_partitions * 8, 0);
    EncodeFixed32(&(*space_)[4], static_cast<uint32_t>(space_->size()));
    Iter bucket_iter(*this);
    for (; bucket_iter.Valid(); bucket_iter.Next()) {
      std::vector<uint32_t>* bucket_keys = bucket_iter.keys();
      std::sort(bucket_keys->begin(), bucket_keys->end());
      for (std::vector<uint32_t>::iterator it = bucket_keys->begin();
           it != bucket_keys->end(); ++it) {
        uint32_t dta = *it - last_key;
        // If a partition becomes full
        if (partition_num_keys == partition_size_) {
          EncodeFixed32(&(*space_)[partition_index++ * 8],
                        partition_dta_prefix);
          EncodeFixed32(&(*space_)[partition_index * 8 + 4],  // Next partition
                        static_cast<uint32_t>(space_->size()));
          partition_num_keys = 0;
        }
        partition_num_keys++;
        partition_dta_prefix += dta;
        VbPlusEnc(space_, dta);
        last_key = *it;
      }
    }

    if (partition_num_keys != 0) {
      EncodeFixed32(&(*space_)[partition_index * 8], partition_dta_prefix);
    }

    return space_->size();
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& bitmap) {
    Slice input = bitmap;
    size_t num_partitions = DecodeFixed32(&input[4]) / 8;
    uint32_t base = 0;
    size_t partition_index = 0;
    for (; partition_index < num_partitions; partition_index++) {
      const uint32_t partition_dta_prefix =
          DecodeFixed32(&input[partition_index * 8]);
      if (bit <= partition_dta_prefix) {
        size_t size = DecodeFixed32(&input[partition_index * 8 + 4]);
        input.remove_prefix(size);
        break;
      } else {
        base = partition_dta_prefix;
      }
    }

    // Search within the target partition
    if (partition_index < num_partitions) {
      while (!input.empty()) {
        base += VbPlusDec(&input);
        if (base == bit) {
          return true;
        } else if (base > bit) {
          return false;
        }
      }
    }

    return false;
  }
};

class PfDelFormat : public CompressedFormat {
 public:
  PfDelFormat(const DirOptions& options, std::string* space)
      : CompressedFormat(options, space) {}

  size_t Finish() {
    std::sort(extra_keys_.begin(), extra_keys_.end());
    size_t overflowed_idx = 0;
    size_t last_one = 0;
    std::vector<size_t> bucket_keys;

    std::vector<size_t> cohort;
    cohort.reserve(cohort_size_);
    size_t cohort_or = 0;
    // For every bucket
    for (size_t i = 0; i < num_buckets_; i++) {
      // Bucket key size
      unsigned char key_num =
          static_cast<unsigned char>(working_space_[bytes_per_bucket_ * i]);
      size_t offset = bytes_per_bucket_ * i + 1;
      // Clear vector for repeated use.
      bucket_keys.clear();
      for (int j = 0; j < key_num; j++) {
        if (j < bytes_per_bucket_ - 1)
          bucket_keys.push_back(
              static_cast<unsigned char>(working_space_[offset + j]) +
              (i << 8));
        else
          bucket_keys.push_back(extra_keys_[overflowed_idx++]);
      }
      std::sort(bucket_keys.begin(), bucket_keys.end());
      for (std::vector<size_t>::iterator it = bucket_keys.begin();
           it != bucket_keys.end(); ++it) {
        size_t distance = *it - last_one;
        last_one = *it;
        // Encoding the distance using pForDelta.
        cohort.push_back(distance);
        cohort_or |= distance;
        // If full
        if (cohort.size() == cohort_size_) {
          EncodingCohort(cohort, cohort_or);
          cohort_or = 0;
          cohort.clear();
        }
      }
    }
    if (cohort.size() > 0) {
      EncodingCohort(cohort, cohort_or);
    }
    return space_->size();
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& input) {
    size_t index = 0;
    size_t cohort_num = 0;
    unsigned char bit_num;
    unsigned char b = 0;
    int byte_index = -1;
    for (size_t i = 0; i < input.size();) {
      assert(byte_index == -1);

      bit_num = static_cast<unsigned char>(input[i++]);
      cohort_num = cohort_size_;
      if ((input.size() - i) * 8 / bit_num < cohort_num) {
        cohort_num = (input.size() - i) * 8 / bit_num;
      }
      while (cohort_num > 0) {
        size_t runLen = 0;
        int runLen_index = bit_num - 1;
        while (runLen_index >= 0) {
          if (byte_index < 0) {
            if (i < input.size()) {
              b = static_cast<unsigned char>(input[i]);
              byte_index = 7;
              i++;
            } else {
              return false;
            }
          }
          runLen |= (b & (1 << byte_index--)) > 0 ? (1 << runLen_index) : 0;
          runLen_index -= 1;
        }
        cohort_num -= 1;
        if (index + runLen == bit)
          return true;
        else if (index + runLen > bit)
          return false;
        else
          index += runLen;
      }
    }
    return false;
  }

 private:
  void EncodingCohort(std::vector<size_t>& cohort, size_t cohort_or) {
    unsigned char bit_num = LeftMostBit(cohort_or);
    space_->push_back(bit_num);

    unsigned char b = 0;  // tmp byte to fill bit by bit
    int byte_index = 7;   // Start fill from the most significant bit.
    int dis_index = bit_num - 1;
    // Encoding cohort
    for (std::vector<size_t>::iterator it = cohort.begin(); it != cohort.end();
         ++it) {
      dis_index = bit_num - 1;
      while (dis_index >= 0) {
        b |= (*it & (1 << dis_index--)) >= 1 ? (1 << byte_index) : 0;
        if (byte_index-- == 0) {
          space_->push_back(b);
          b = 0;
          byte_index = 7;
        }
      }
    }
    if (byte_index != 7) {
      space_->push_back(b);
    }
  }

  // We assume that cohort size is multiple of 8.
  const static size_t cohort_size_ = 128;
};

class FastPfDelFormat : public CompressedFormat {
 public:
  FastPfDelFormat(const DirOptions& options, std::string* space)
      : CompressedFormat(options, space) {}

  size_t Finish() {
    // Header partition lookup table related variable.
    size_t num_partition = (num_keys_ + partition_size_ - 1) / partition_size_;
    // For each partition, reserve a space to store a total RL and start index
    space_->resize(num_partition == 0 ? 8 : num_partition * 8);
    size_t parti_ele_count = 0;
    size_t parti_total_rl = 0;
    size_t parti_index = 0;
    // Starting address of current partition
    EncodingSizeT(space_, parti_index * 8 + 4, space_->size());

    std::sort(extra_keys_.begin(), extra_keys_.end());
    size_t overflowed_idx = 0;
    size_t last_one = 0;
    std::vector<size_t> bucket_keys;

    std::vector<size_t> cohort;
    cohort.reserve(cohort_size_);
    size_t cohort_or = 0;
    // For every bucket
    for (size_t i = 0; i < num_buckets_; i++) {
      // Bucket key size
      unsigned char key_num =
          static_cast<unsigned char>(working_space_[bytes_per_bucket_ * i]);
      size_t offset = bytes_per_bucket_ * i + 1;
      // Clear vector for repeated use.
      bucket_keys.clear();
      for (int j = 0; j < key_num; j++) {
        if (j < bytes_per_bucket_ - 1)
          bucket_keys.push_back(
              static_cast<unsigned char>(working_space_[offset + j]) +
              (i << 8));
        else
          bucket_keys.push_back(extra_keys_[overflowed_idx++]);
      }
      std::sort(bucket_keys.begin(), bucket_keys.end());
      for (std::vector<size_t>::iterator it = bucket_keys.begin();
           it != bucket_keys.end(); ++it) {
        size_t distance = *it - last_one;
        last_one = *it;

        // If partition is full
        if (parti_ele_count == partition_size_) {
          assert(cohort.size() == 0);
          EncodingSizeT(space_, parti_index * 8, parti_total_rl);
          parti_ele_count = 0;
          parti_total_rl = 0;
          parti_index += 1;
          EncodingSizeT(space_, parti_index * 8 + 4, space_->size());
        }
        // Update partition stats
        parti_total_rl += distance;
        parti_ele_count += 1;

        // Encoding the distance using pForDelta.
        cohort.push_back(distance);
        cohort_or |= distance;
        // If full
        if (cohort.size() == cohort_size_) {
          EncodingCohort(cohort, cohort_or);
          cohort_or = 0;
          cohort.clear();
        }
      }
    }
    if (cohort.size() > 0) {
      EncodingCohort(cohort, cohort_or);
    }

    // If partition is not empty
    if (parti_ele_count != 0) {
      EncodingSizeT(space_, parti_index * 8, parti_total_rl);
    }
    return space_->size();
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& input) {
    // Skip partitions
    size_t start_rl = 0;
    size_t partition_num = DecodingSizeT(input, 4) / 8;

    size_t parti_idx = 0;
    for (; parti_idx < partition_num; parti_idx++) {
      size_t parti_rl = DecodingSizeT(input, parti_idx * 8);
      if (bit > parti_rl) {
        bit -= parti_rl;
      } else {
        start_rl = DecodingSizeT(input, parti_idx * 8 + 4);
        break;
      }
    }

    // Out of range
    if (parti_idx == partition_num) {
      return false;
    }

    size_t index = 0;
    size_t cohort_num = 0;
    unsigned char bit_num;
    unsigned char b = 0;
    int byte_index = -1;
    for (size_t i = start_rl; i < input.size();) {
      assert(byte_index == -1);

      bit_num = static_cast<unsigned char>(input[i++]);

      cohort_num = cohort_size_;
      if ((input.size() - i) * 8 / bit_num < cohort_num) {
        cohort_num = (input.size() - i) * 8 / bit_num;
      }
      while (cohort_num > 0) {
        size_t runLen = 0;
        int runLen_index = bit_num - 1;
        while (runLen_index >= 0) {
          if (byte_index < 0) {
            if (i < input.size()) {
              b = static_cast<unsigned char>(input[i]);
              byte_index = 7;
              i++;
            } else {
              return false;
            }
          }
          runLen |= (b & (1 << byte_index--)) > 0 ? (1 << runLen_index) : 0;
          runLen_index -= 1;
        }

        cohort_num -= 1;
        if (index + runLen == bit)
          return true;
        else if (index + runLen > bit)
          return false;
        else
          index += runLen;
      }
    }
    return false;
  }

 private:
  void EncodingCohort(std::vector<size_t>& cohort, size_t cohort_or) {
    unsigned char bit_num = LeftMostBit(cohort_or);
    space_->push_back(bit_num);

    unsigned char b = 0;  // tmp byte to fill bit by bit
    int byte_index = 7;   // Start fill from the most significant bit.
    int dis_index = bit_num - 1;
    // Encoding cohort
    for (std::vector<size_t>::iterator it = cohort.begin(); it != cohort.end();
         ++it) {
      dis_index = bit_num - 1;
      while (dis_index >= 0) {
        b |= (*it & (1 << dis_index--)) >= 1 ? (1 << byte_index) : 0;
        if (byte_index-- == 0) {
          space_->push_back(b);
          b = 0;
          byte_index = 7;
        }
      }
    }
    if (byte_index != 7) {
      space_->push_back(b);
    }
  }

  // We assume that cohort size is multiple of 8.
  const static size_t cohort_size_ = 128;
};

// Roaring bitmap format bucket size 2^8
class RoaringFormat : public CompressedFormat {
 public:
  RoaringFormat(const DirOptions& options, std::string* space)
      : CompressedFormat(options, space) {}

  void Reset(uint32_t num_keys) {
    CompressedFormat::Reset(num_keys);
    bucket_size_max_bit_ = 0;
  }

  void Set(uint32_t i) {
    // Copy from parent
    int bucket_index = i >> 8;
    // Read bucket key number
    unsigned char key_index = working_space_[bucket_index * bytes_per_bucket_];
    if (key_index < bytes_per_bucket_ - 1) {
      // Append to the bucket
      working_space_[bucket_index * bytes_per_bucket_ + key_index + 1] =
          i & ((1 << 8) - 1);
    } else {
      // Append to overflow vector
      extra_keys_.push_back(i);
    }
    // Update the bucket key number
    working_space_[bucket_index * bytes_per_bucket_] = key_index + 1;

    // Update max bit
    bucket_size_max_bit_ |= static_cast<size_t>(key_index + 1);
  }

  size_t Finish() {
    std::sort(extra_keys_.begin(), extra_keys_.end());
    size_t overflowed_idx = 0;

    unsigned char bits_per_len = LeftMostBit(bucket_size_max_bit_);
    space_->resize(1 + (bits_per_len * num_buckets_ + 7) / 8, 0);
    (*space_)[0] = bits_per_len;

    // Leave the space at the head to store the size for every buckets
    // The index of the byte at space_ to encode bucket size.
    size_t bucket_len_byte_idx = 1;

    unsigned char bucket_len_byte = 0;
    int bucket_len_bit_idx = 7;  // The index of bit in the constructing byte.

    std::vector<unsigned char> bucket_keys;
    // For every bucket
    for (size_t i = 0; i < num_buckets_; i++) {
      // Bucket key size
      unsigned char key_num =
          static_cast<unsigned char>(working_space_[bytes_per_bucket_ * i]);
      size_t offset = bytes_per_bucket_ * i + 1;
      // Clear vector for repeated use.
      bucket_keys.clear();
      for (int j = 0; j < key_num; j++) {
        if (j < bytes_per_bucket_ - 1)
          bucket_keys.push_back(
              static_cast<unsigned char>(working_space_[offset + j]));
        else
          bucket_keys.push_back(
              static_cast<unsigned char>(extra_keys_[overflowed_idx++] & 255));
      }
      std::sort(bucket_keys.begin(), bucket_keys.end());
      // Encoding bucket size
      int len_index = bits_per_len - 1;
      while (len_index >= 0) {
        bucket_len_byte |=
            (key_num & (1 << len_index--)) >= 1 ? (1 << bucket_len_bit_idx) : 0;
        if (bucket_len_bit_idx-- == 0) {
          (*space_)[bucket_len_byte_idx++] = bucket_len_byte;
          bucket_len_byte = 0;
          bucket_len_bit_idx = 7;
        }
      }
      // Fill the offsets of the bucket
      for (std::vector<unsigned char>::iterator it = bucket_keys.begin();
           it != bucket_keys.end(); ++it) {
        // Encoding the distance to roaring bitmap encode.
        space_->push_back(*it);
      }
    }

    if (bucket_len_bit_idx != 7) {
      (*space_)[bucket_len_byte_idx] = bucket_len_byte;
      ;
    }

    return space_->size();
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& input) {
    uint32_t bucket_idx = bit >> 8;
    unsigned char bit_per_len = input[0];
    int len_byte_idx = 1;
    size_t offset = 0;
    size_t len;

    // Get the offset of the bucket
    unsigned char b = 0;
    int b_idx = -1;
    while (bucket_idx-- > 0) {
      len = 0;
      int len_index = bit_per_len - 1;
      while (len_index >= 0) {
        if (b_idx < 0) {
          b = static_cast<unsigned char>(input[len_byte_idx++]);
          b_idx = 7;
        }
        len |= (b & (1 << b_idx--)) > 0 ? (1 << len_index) : 0;
        len_index -= 1;
      }
      offset += len;
    }

    // Get the size of the bucket
    size_t bucket_size = 0;
    int bucket_size_index = bit_per_len - 1;
    while (bucket_size_index >= 0) {
      if (b_idx < 0) {
        b = static_cast<unsigned char>(input[len_byte_idx++]);
        b_idx = 7;
      }
      bucket_size |= (b & (1 << b_idx--)) > 0 ? (1 << bucket_size_index) : 0;
      bucket_size_index -= 1;
    }

    size_t start_idx =
        1 + ((1 << (key_bits - 8)) /*bucket number*/ * bit_per_len + 7) / 8 +
        offset;
    unsigned char target_offset = static_cast<unsigned char>(bit & 255);
    unsigned char key_offset;
    for (size_t i = start_idx; i < start_idx + bucket_size; i++) {
      key_offset = static_cast<unsigned char>(input[i]);
      if (key_offset == target_offset)
        return true;
      else if (key_offset > target_offset)
        return false;
    }
    return false;
  }

 private:
  size_t bucket_size_max_bit_ = 0;
};

// Partitioned Roaring bitmap format bucket size 2^8
class FastRoaringFormat : public CompressedFormat {
 public:
  FastRoaringFormat(const DirOptions& options, std::string* space)
      : CompressedFormat(options, space), partition_num_(num_buckets_ >> 8) {}

  void Reset(uint32_t num_keys) {
    CompressedFormat::Reset(num_keys);

    bucket_size_max_bit_ = 0;
    partition_sum_.resize(partition_num_, 0);
  }

  void Set(uint32_t i) {
    // Copy from parent
    int bucket_index = i >> 8;
    // Read bucket key number
    unsigned char key_index = working_space_[bucket_index * bytes_per_bucket_];
    if (key_index < bytes_per_bucket_ - 1) {
      // Append to the bucket
      working_space_[bucket_index * bytes_per_bucket_ + key_index + 1] =
          i & 0xff;
    } else {
      // Append to overflow vector
      extra_keys_.push_back(i);
    }
    // Update the bucket key number
    working_space_[bucket_index * bytes_per_bucket_] = key_index + 1;

    int partition_index = bucket_index >> 8;
    // Update max bit
    bucket_size_max_bit_ |= static_cast<size_t>(key_index + 1);
    partition_sum_[partition_index] += 1;
  }

  size_t Finish() {
    std::sort(extra_keys_.begin(), extra_keys_.end());
    size_t overflowed_idx = 0;

    // Reserve space for header (partition sum & bits)
    space_->resize(partition_num_ * sizeof(uint16_t) + 1, 0);

    for (size_t i = 0; i < partition_num_; i++) {
      (*space_)[2 * i] = static_cast<char>(partition_sum_[i] & 0xff);
      (*space_)[2 * i + 1] = static_cast<char>((partition_sum_[i] >> 8) & 0xff);
    }

    unsigned char bits_per_len = LeftMostBit(bucket_size_max_bit_);
    (*space_)[partition_num_ * sizeof(uint16_t)] = bits_per_len;

    // Leave the space at the head to store the size for every buckets
    // The index of the byte at space_ to encode bucket size.
    size_t bucket_len_byte_idx = space_->size();

    space_->resize(space_->size() + (bits_per_len * num_buckets_ + 7) / 8, 0);

    unsigned char bucket_len_byte = 0;
    int bucket_len_bit_idx = 7;  // The index of bit in the constructing byte.

    std::vector<unsigned char> bucket_keys;
    // For every bucket
    for (size_t i = 0; i < num_buckets_; i++) {
      // Bucket key size
      unsigned char key_num =
          static_cast<unsigned char>(working_space_[bytes_per_bucket_ * i]);
      size_t offset = bytes_per_bucket_ * i + 1;
      // Clear vector for repeated use.
      bucket_keys.clear();
      for (int j = 0; j < key_num; j++) {
        if (j < bytes_per_bucket_ - 1)
          bucket_keys.push_back(
              static_cast<unsigned char>(working_space_[offset + j]));
        else
          bucket_keys.push_back(
              static_cast<unsigned char>(extra_keys_[overflowed_idx++] & 255));
      }
      std::sort(bucket_keys.begin(), bucket_keys.end());
      // Encoding bucket size
      int len_index = bits_per_len - 1;
      while (len_index >= 0) {
        bucket_len_byte |=
            (key_num & (1 << len_index--)) >= 1 ? (1 << bucket_len_bit_idx) : 0;
        if (bucket_len_bit_idx-- == 0) {
          (*space_)[bucket_len_byte_idx++] = bucket_len_byte;
          bucket_len_byte = 0;
          bucket_len_bit_idx = 7;
        }
      }
      // Fill the offsets of the bucket
      for (std::vector<unsigned char>::iterator it = bucket_keys.begin();
           it != bucket_keys.end(); ++it) {
        // Encoding the distance to roaring bitmap encode.
        space_->push_back(*it);
      }
    }

    if (bucket_len_bit_idx != 7) {
      (*space_)[bucket_len_byte_idx] = bucket_len_byte;
      ;
    }

    return space_->size();
  }

  static bool Test(uint32_t bit, size_t key_bits, const Slice& input) {
    size_t partition_idx = bit >> 16;
    size_t bucket_idx = (bit & 0xff00) >> 8;
    size_t bucket_number = 1 << (key_bits - 8);
    size_t partition_num = bucket_number >> 8;

    size_t offset = 0;
    // Traverse partition lookup table
    for (int i = 0; i < partition_idx; i++) {
      offset += (input[2 * i] + (input[2 * i + 1] << 8));
    }

    unsigned char bit_per_len = input[2 * partition_num];
    int len_byte_idx =
        2 * partition_num + 1 +
        (bit_per_len * partition_idx << (8 - 3));  // *256 / 8(bits/byte)
    size_t len;

    // Get the offset of the bucket
    unsigned char b = 0;
    int b_idx = -1;
    while (bucket_idx-- > 0) {
      len = 0;
      int len_index = bit_per_len - 1;
      while (len_index >= 0) {
        if (b_idx < 0) {
          b = static_cast<unsigned char>(input[len_byte_idx++]);
          b_idx = 7;
        }
        len |= (b & (1 << b_idx--)) > 0 ? (1 << len_index) : 0;
        len_index -= 1;
      }
      offset += len;
    }

    // Get the size of the bucket
    size_t bucket_size = 0;
    int bucket_size_index = bit_per_len - 1;
    while (bucket_size_index >= 0) {
      if (b_idx < 0) {
        b = static_cast<unsigned char>(input[len_byte_idx++]);
        b_idx = 7;
      }
      bucket_size |= (b & (1 << b_idx--)) > 0 ? (1 << bucket_size_index) : 0;
      bucket_size_index -= 1;
    }

    size_t start_idx =
        2 * partition_num + 1 + (bucket_number * bit_per_len + 7) / 8 + offset;
    unsigned char target_offset = static_cast<unsigned char>(bit & 0xff);
    unsigned char key_offset;
    for (size_t i = start_idx; i < start_idx + bucket_size; i++) {
      key_offset = static_cast<unsigned char>(input[i]);
      if (key_offset == target_offset)
        return true;
      else if (key_offset > target_offset)
        return false;
    }
    return false;
  }

  size_t memory_usage() const {
    return CompressedFormat::memory_usage() +
           partition_sum_.size() * sizeof(uint16_t);
  }

 private:
  size_t partition_num_;
  size_t bucket_size_max_bit_ = 0;
  std::vector<uint16_t> partition_sum_;
};

template <typename T>
int BitmapBlock<T>::chunk_type() {
  return static_cast<int>(kBmpChunk);
}

template <typename T>
BitmapBlock<T>::BitmapBlock(const DirOptions& options, size_t bytes_to_reserve)
    : key_bits_(options.bm_key_bits) {
  // Reserve extra 2 bytes for storing key_bits and the compression type
  if (bytes_to_reserve != 0) {
    space_.reserve(bytes_to_reserve + 2);
  }
  fmt_ = new T(options, &space_);
  finished_ = true;  // Pending further initialization
  mask_ = ~static_cast<uint32_t>(0) << key_bits_;
  mask_ = ~mask_;
}

template <typename T>
void BitmapBlock<T>::Reset(uint32_t num_keys) {
  assert(fmt_ != NULL);
  fmt_->Reset(num_keys);
  finished_ = false;
}

// To convert a key into an int, the first 4 bytes of the key is interpreted
// as the little-endian representation of a 32-bit int. As illustrated below,
// the conversion may be seen as using the "first" 32 bits of the byte array
// to construct an int.
//
// [07.06.05.04.03.02.01.00]  [15.14.13.12.11.10.09.08] [...] [...]
//  <------------ byte 0 ->    <------------ byte 1 ->
//
static uint32_t BitmapIndex(const Slice& key) {
  char tmp[4];
  memset(tmp, 0, sizeof(tmp));
  memcpy(tmp, key.data(), std::min(key.size(), sizeof(tmp)));
  return DecodeFixed32(tmp);
}

// Insert a key (1-4 bytes) into the bitmap filter. If the key has more than 4
// bytes, the rest bytes are ignored. If a key has less than 4 bytes, it will
// be zero-padded to 4 bytes. Inserting a key is achieved by first converting
// the key into an int, i, and then setting the i-th bit of the bitmap to "1".
template <typename T>
void BitmapBlock<T>::AddKey(const Slice& key) {
  assert(!finished_);  // Finish() has not been called
  uint32_t i = BitmapIndex(key);
  i &= mask_;
  assert(fmt_ != NULL);
  fmt_->Set(i);
}

template <typename T>
Slice BitmapBlock<T>::Finish() {
  assert(fmt_ != NULL);
  finished_ = true;
  size_t len = fmt_->Finish();
  space_.resize(len);
  // Remember the size of the domain space
  space_.push_back(static_cast<char>(key_bits_));
  // Remember the compression type
  if (typeid(T) == typeid(UncompressedFormat)) {
    space_.push_back(static_cast<char>(kFmtUncompressed));
  } else if (typeid(T) == typeid(VbFormat)) {
    space_.push_back(static_cast<char>(kFmtVarint));
  } else if (typeid(T) == typeid(VbPlusFormat)) {
    space_.push_back(static_cast<char>(kFmtVarintPlus));
  } else if (typeid(T) == typeid(FastVbPlusFormat)) {
    space_.push_back(static_cast<char>(kFmtFastVarintPlus));
  } else if (typeid(T) == typeid(PfDelFormat)) {
    space_.push_back(static_cast<char>(kFmtPfDelta));
  } else if (typeid(T) == typeid(FastPfDelFormat)) {
    space_.push_back(static_cast<char>(kFmtFastPfDelta));
  } else if (typeid(T) == typeid(RoaringFormat)) {
    space_.push_back(static_cast<char>(kFmtRoaring));
  } else if (typeid(T) == typeid(FastRoaringFormat)) {
    space_.push_back(static_cast<char>(kFmtFastRoaring));
  }
  return space_;
}

template <typename T>
size_t BitmapBlock<T>::memory_usage() const {
  return fmt_->memory_usage();
}

template <typename T>
BitmapBlock<T>::~BitmapBlock() {
  delete fmt_;
}

template class BitmapBlock<UncompressedFormat>;

template class BitmapBlock<VbFormat>;

template class BitmapBlock<VbPlusFormat>;

template class BitmapBlock<FastVbPlusFormat>;

template class BitmapBlock<PfDelFormat>;

template class BitmapBlock<FastPfDelFormat>;

template class BitmapBlock<RoaringFormat>;

template class BitmapBlock<FastRoaringFormat>;

// Return true if the target key matches a given bitmap filter. Unlike bloom
// filters, bitmap filters are designed with no false positives.
bool BitmapKeyMustMatch(const Slice& key, const Slice& input) {
  const size_t len = input.size();
  if (len < 2) {
    return false;  // Empty bitmap
  }

  Slice bitmap =
      input;  // Net bitmap representation (maybe in a compressed form)
  bitmap.remove_suffix(2);
  uint32_t i = BitmapIndex(key);

  // Recover the domain space
  const size_t key_bits = static_cast<unsigned char>(input[input.size() - 2]);

  size_t bits = 1u << key_bits;
  if (i >= bits) {
    return false;  // Out of bound
  }

  const int compression = input[input.size() - 1];
  if (compression == kFmtUncompressed) {
    return UncompressedFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtVarint) {
    return VbFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtVarintPlus) {
    return VbPlusFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtFastVarintPlus) {
    return FastVbPlusFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtPfDelta) {
    return PfDelFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtFastPfDelta) {
    return FastPfDelFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtRoaring) {
    return RoaringFormat::Test(i, key_bits, bitmap);
  } else if (compression == kFmtFastRoaring) {
    return FastRoaringFormat::Test(i, key_bits, bitmap);
  } else {
    return true;
  }
}

int EmptyFilterBlock::chunk_type() { return static_cast<int>(kUnknown); }

EmptyFilterBlock::EmptyFilterBlock(const DirOptions& o, size_t b) {
  space_.resize(0);
#if __cplusplus >= 201103L
  space_.shrink_to_fit();  // not available before c++11
#endif
}

}  // namespace plfsio
}  // namespace pdlfs
